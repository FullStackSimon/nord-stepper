{"version":3,"file":"SegmentedControlItem.js","sources":["../src/segmented-control-item/SegmentedControlItem.ts"],"sourcesContent":["import { LitElement, html, nothing } from \"lit\"\nimport { customElement, property } from \"lit/decorators.js\"\nimport { ref } from \"lit/directives/ref.js\"\nimport { observe } from \"../common/decorators/observe.js\"\nimport { cond } from \"../common/directives/cond.js\"\nimport { LightDomController } from \"../common/controllers/LightDomController.js\"\nimport { LightSlotController } from \"../common/controllers/LightSlotController.js\"\nimport { NordEvent } from \"../common/events.js\"\n\nimport { FocusableMixin } from \"../common/mixins/FocusableMixin.js\"\nimport { InputMixin } from \"../common/mixins/InputMixin.js\"\n\nimport componentStyle from \"../common/styles/Component.css\"\nimport style from \"./SegmentedControlItem.css\"\n\nlet id = 0\nconst createId = (suffix: string) => `nord-segmented-control-item-${suffix}-${id++}`\n\nfunction isLabel(element: Element): element is HTMLLabelElement {\n  return element.localName === \"label\"\n}\n\ntype NativeInputElement = HTMLSelectElement | HTMLInputElement | HTMLTextAreaElement\n\n/**\n * Segmented control items populate a segmented control with options.\n * Every item should be placed inside a segmented control.\n *\n * @status new\n * @category action\n * @slot label - Use when a label requires more than plain text.\n *\n * @cssprop [--n-segmented-control-item-border-radius=var(--n-border-radius-s)] - Controls the rounded corners of the item, using [border radius tokens](/tokens/#border-radius).\n * @cssprop [--n-segmented-control-item-gap=var(--n-space-xs)] - Controls the spacing between elements within the item, using our [spacing tokens](/tokens/#space).\n * @cssprop [--n-segmented-control-item-gradient=linear-gradient(to bottom, rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, 0.013) 100%))] - Controls the overlayed gradient background on the item.\n * @cssprop [--n-segmented-control-item-background-color=var(--n-color-nav-hover)] - Controls the background color of the item, using our [color tokens](/tokens/#color).\n * @cssprop [--n-segmented-control-item-color=var(--n-color-text-weaker)] - Controls the color of the text within the item, using our [color tokens](/tokens/#color).\n * @cssprop [--n-segmented-control-item-padding-inline=calc(var(--n-space-m) / 1.2)] - Controls the inline, or left and right, padding of the item.\n * @cssprop [--n-segmented-control-item-box-shadow=none] - Controls the surrounding shadow, using our [box shadow tokens](/tokens/#box-shadow).\n * @cssprop [--n-segmented-control-item-font-size=var(--n-font-size-m)] - Controls the size of the text within the item, using our [font tokens](/tokens/#font).\n * @cssprop [--n-segmented-control-item-font-weight=var(--n-font-weight)] - Controls the weight of the text within the item, using our [font tokens](/tokens/#font).\n * @cssprop [--n-segmented-control-item-min-block-size=calc(var(--n-space-xl) - 2px)] - Controls the minimum block size, or height, of the item using our [spacing tokens](/tokens/#space).\n * @cssprop [--n-segmented-control-item-inline-size=auto] - Controls the inline size of the item.\n */\n@customElement(\"nord-segmented-control-item\")\nexport default class SegmentedControlItem extends InputMixin(FocusableMixin(LitElement)) {\n  static styles = [componentStyle, style]\n\n  protected inputId = createId(\"input\")\n\n  /**\n   * For accessibility reasons, we render the form parts of the component to the light DOM.\n   */\n  protected inputSlot = new LightDomController(this, {\n    render: () => html`\n      <input\n        slot=\"input\"\n        @blur=${this.handleBlur}\n        @focus=${this.handleFocus}\n        ${ref(this.focusableRef)}\n        id=${this.inputId}\n        type=\"radio\"\n        class=\"n-input\"\n        name=${cond(this.name)}\n        .value=${cond(this.value)}\n        .checked=${this.checked}\n        ?disabled=${this.disabled}\n        form=${cond(this._formId)}\n      />\n    `,\n  })\n\n  protected labelSlot = new LightSlotController(this, {\n    slotName: \"label\",\n    render: () =>\n      this.label\n        ? html`<label slot=\"label-internal\" for=${this.inputId} class=\"n-segmented-control-item\">${this.label}</label>`\n        : nothing,\n    syncLightDom: element => {\n      if (!isLabel(element)) {\n        // eslint-disable-next-line no-console\n        console.warn(`NORD: Only <label> elements should be placed in Segmented Control's \"label\" slot`)\n      } else {\n        element.htmlFor = this.inputId\n      }\n    },\n  })\n\n  /**\n   * Controls whether the segmented control item is checked or not.\n   */\n  @property({ type: Boolean, reflect: true }) checked: boolean = false\n\n  /**\n   * The size of the segmented control item.\n   * This affects font-size and padding.\n   */\n  @property({ reflect: true }) size: \"s\" | \"m\" | \"l\" = \"m\"\n\n  /**\n   * Label for the segmented control item.\n   */\n  @property({ reflect: true }) label: string = \"\"\n\n  render() {\n    return html`<div class=\"n-segmented-control-item\" @change=${this.handleChange}>\n      <slot name=\"input\"></slot>\n      <slot name=\"label\"></slot>\n      <slot name=\"label-internal\"></slot>\n    </div>`\n  }\n\n  @observe(\"checked\")\n  protected handleCheckedChange(previousChecked: boolean) {\n    // if this component was previous unchecked but is now checked,\n    // then we need to uncheck any items in the same group\n    if (!previousChecked && this.checked) {\n      this.uncheckSiblings()\n    }\n  }\n\n  private uncheckSiblings() {\n    const root = this.getRootNode() as Document | ShadowRoot\n\n    root\n      .querySelectorAll<SegmentedControlItem>(`nord-segmented-control-item[name=\"${this.name}\"]`)\n      .forEach(segmentedControlItem => {\n        if (segmentedControlItem !== this) {\n          segmentedControlItem.checked = false\n        }\n      })\n  }\n\n  protected handleChange(e: Event): void {\n    const target = e.target as HTMLInputElement\n    this.checked = target.checked\n\n    e.stopPropagation()\n\n    /**\n     * Fired whenever the segmented control item has been checked.\n     */\n    this.dispatchEvent(new NordEvent(\"change\"))\n  }\n\n  private handleBlur = (e: Event) => {\n    e.stopPropagation()\n    this.dispatchEvent(new Event(\"blur\", { bubbles: false, cancelable: true }))\n  }\n\n  private handleFocus = (e: Event) => {\n    e.stopPropagation()\n    this.dispatchEvent(new Event(\"focus\", { bubbles: false, cancelable: true }))\n  }\n\n  protected handleInput(e: Event) {\n    e.stopPropagation()\n    const target = e.target as NativeInputElement\n    this.value = target.value\n\n    /**\n     * Fired as the user types into the input.\n     */\n    this.dispatchEvent(new NordEvent(\"input\"))\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"nord-segmented-control-item\": SegmentedControlItem\n  }\n}\n"],"names":["id","SegmentedControlItem","InputMixin","FocusableMixin","LitElement","constructor","this","inputId","inputSlot","LightDomController","render","html","handleBlur","handleFocus","ref","focusableRef","cond","name","value","checked","disabled","_formId","labelSlot","LightSlotController","slotName","label","nothing","syncLightDom","element","localName","isLabel","console","warn","htmlFor","size","e","stopPropagation","dispatchEvent","Event","bubbles","cancelable","handleChange","handleCheckedChange","previousChecked","uncheckSiblings","getRootNode","querySelectorAll","forEach","segmentedControlItem","target","NordEvent","handleInput","styles","componentStyle","style","__decorate","property","type","Boolean","reflect","prototype","observe","customElement"],"mappings":"kvNAeA,IAAIA,EAAK,EA8BM,IAAMC,EAAN,cAAmCC,EAAWC,EAAeC,KAA7D,WAAAC,uBAGHC,KAAAC,QAhCyB,+BAgCN,WAhC+CP,MAqClEM,KAAAE,UAAY,IAAIC,EAAmBH,KAAM,CACjDI,OAAQ,IAAMC,CAAI,8BAGNL,KAAKM,uBACJN,KAAKO,gBACZC,EAAIR,KAAKS,qBACNT,KAAKC,+CAGHS,EAAKV,KAAKW,kBACRD,EAAKV,KAAKY,qBACRZ,KAAKa,uBACJb,KAAKc,mBACVJ,EAAKV,KAAKe,eAKbf,KAAAgB,UAAY,IAAIC,EAAoBjB,KAAM,CAClDkB,SAAU,QACVd,OAAQ,IACNJ,KAAKmB,MACDd,CAAI,qCAAoCL,KAAKC,6CAA4CD,KAAKmB,gBAC9FC,EACNC,aAAcC,KA5DlB,SAAiBA,GACf,MAA6B,UAAtBA,EAAQC,SACjB,CA2DWC,CAAQF,GAEXG,QAAQC,KAAK,qFAEbJ,EAAQK,QAAU3B,KAAKC,OACxB,IAOuCD,KAAOa,SAAY,EAMlCb,KAAI4B,KAAoB,IAKxB5B,KAAKmB,MAAW,GA2CrCnB,KAAAM,WAAcuB,IACpBA,EAAEC,kBACF9B,KAAK+B,cAAc,IAAIC,MAAM,OAAQ,CAAEC,SAAS,EAAOC,YAAY,IAAQ,EAGrElC,KAAAO,YAAesB,IACrBA,EAAEC,kBACF9B,KAAK+B,cAAc,IAAIC,MAAM,QAAS,CAAEC,SAAS,EAAOC,YAAY,IAAQ,CAa/E,CA7DC,MAAA9B,GACE,OAAOC,CAAI,kDAAiDL,KAAKmC,6GAKlE,CAGS,mBAAAC,CAAoBC,IAGvBA,GAAmBrC,KAAKa,SAC3Bb,KAAKsC,iBAER,CAEO,eAAAA,GACOtC,KAAKuC,cAGfC,iBAAuC,qCAAqCxC,KAAKW,UACjF8B,SAAQC,IACHA,IAAyB1C,OAC3B0C,EAAqB7B,SAAU,EAChC,GAEN,CAES,YAAAsB,CAAaN,GACrB,MAAMc,EAASd,EAAEc,OACjB3C,KAAKa,QAAU8B,EAAO9B,QAEtBgB,EAAEC,kBAKF9B,KAAK+B,cAAc,IAAIa,EAAU,UAClC,CAYS,WAAAC,CAAYhB,GACpBA,EAAEC,kBACF,MAAMa,EAASd,EAAEc,OACjB3C,KAAKY,MAAQ+B,EAAO/B,MAKpBZ,KAAK+B,cAAc,IAAIa,EAAU,SAClC,GAtHMjD,EAAAmD,OAAS,CAACC,EAAgBC,GA6CWC,EAAA,CAA3CC,EAAS,CAAEC,KAAMC,QAASC,SAAS,KAAgC1D,EAAA2D,UAAA,eAAA,GAMvCL,EAAA,CAA5BC,EAAS,CAAEG,SAAS,KAAmC1D,EAAA2D,UAAA,YAAA,GAK3BL,EAAA,CAA5BC,EAAS,CAAEG,SAAS,KAA0B1D,EAAA2D,UAAA,aAAA,GAWrCL,EAAA,CADTM,EAAQ,YAOR5D,EAAA2D,UAAA,sBAAA,MA1EkB3D,EAAoBsD,EAAA,CADxCO,EAAc,gCACM7D,SAAAA"}